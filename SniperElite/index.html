<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sniper Elite: Nightfall Protocol</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Roboto+Mono:wght@400;700&display=swap');
        
        :root {
            --hud-color: #00ff41;
            --alert-color: #ff3333;
            --bg-color: #050505;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; -webkit-user-select: none; }
        
        body {
            background: var(--bg-color);
            font-family: 'Roboto Mono', monospace;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            cursor: crosshair;
        }

        #gameContainer {
            position: relative;
            width: 100%;
            height: 100%;
            background: #000;
        }

        canvas { display: block; }

        /* --- UI LAYOUT --- */
        .ui-layer {
            position: absolute;
            pointer-events: none;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            z-index: 10;
        }

        /* NVG Overlay Effect */
        .nvg-overlay {
            background: 
                linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%),
                linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 5;
            mix-blend-mode: overlay;
        }

        .vignette {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 60%, black 100%);
            pointer-events: none;
            z-index: 6;
        }

        /* --- HUD ELEMENTS --- */
        #hud-top {
            display: flex;
            justify-content: space-between;
            padding: 20px;
            color: var(--hud-color);
            text-shadow: 0 0 5px var(--hud-color);
        }

        .info-box {
            background: rgba(0, 20, 0, 0.6);
            border: 1px solid var(--hud-color);
            padding: 10px;
            border-radius: 4px;
        }

        .stat-label { font-size: 12px; opacity: 0.8; }
        .stat-value { font-size: 20px; font-weight: bold; font-family: 'Black Ops One', cursive; }

        #wind-indicator {
            position: absolute;
            top: 80px;
            left: 20px;
            width: 100px;
            height: 4px;
            background: #333;
            border: 1px solid var(--hud-color);
        }
        
        #wind-bar {
            height: 100%;
            background: var(--hud-color);
            width: 50%; /* Center */
            transform-origin: center;
            transition: width 0.5s, transform 0.5s;
        }

        #reload-indicator {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            color: var(--alert-color);
            font-weight: bold;
            display: none;
            font-family: 'Black Ops One';
            letter-spacing: 2px;
            animation: blink 0.5s infinite;
        }

        /* --- SCOPE --- */
        #scope-overlay {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 100vmax; /* Cover screen */
            height: 100vmax;
            border-radius: 50%;
            box-shadow: 0 0 0 100vmax black;
            border: 2px solid var(--hud-color);
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
            z-index: 20;
            background: radial-gradient(circle, rgba(0,255,0,0.05) 0%, rgba(0,0,0,0.5) 90%);
        }

        #crosshair {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            opacity: 0.8;
            transition: transform 0.1s;
        }

        /* --- MOBILE CONTROLS --- */
        #mobile-controls {
            display: none;
            position: absolute;
            bottom: 20px;
            width: 100%;
            padding: 0 20px;
            justify-content: space-between;
            pointer-events: auto;
            z-index: 100;
        }

        .touch-btn {
            width: 70px; height: 70px;
            border-radius: 50%;
            border: 2px solid var(--hud-color);
            background: rgba(0, 50, 0, 0.5);
            color: var(--hud-color);
            display: flex; align-items: center; justify-content: center;
            font-weight: bold;
            font-size: 12px;
        }
        
        .touch-btn:active { background: var(--hud-color); color: black; }
        
        #aim-pad {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 9;
            display: none; /* Active only on touch */
        }

        /* --- ANIMATIONS --- */
        @keyframes blink { 50% { opacity: 0; } }
        @keyframes recoil {
            0% { transform: translate(-50%, -50%) scale(1); }
            10% { transform: translate(-50%, -45%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        /* --- MENUS --- */
        .menu-screen {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 10, 0, 0.95);
            border: 1px solid var(--hud-color);
            padding: 40px;
            text-align: center;
            color: var(--hud-color);
            z-index: 200;
            min-width: 300px;
            box-shadow: 0 0 50px rgba(0, 255, 0, 0.2);
        }
        
        .btn {
            background: transparent;
            border: 1px solid var(--hud-color);
            color: var(--hud-color);
            padding: 10px 30px;
            margin-top: 20px;
            font-family: 'Black Ops One';
            font-size: 18px;
            cursor: pointer;
            transition: 0.2s;
        }
        .btn:hover { background: var(--hud-color); color: black; }

        @media (hover: none) and (pointer: coarse) {
            #mobile-controls { display: flex; }
            #aim-pad { display: block; }
            body { cursor: none; }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div class="nvg-overlay"></div>
        <div class="vignette"></div>

        <!-- UI Layer -->
        <div class="ui-layer">
            <div id="hud-top">
                <div class="info-box">
                    <div class="stat-label">MISSION</div>
                    <div class="stat-value" id="mission-disp">01</div>
                </div>
                <div class="info-box">
                    <div class="stat-label">TARGETS</div>
                    <div class="stat-value" id="target-disp">0/0</div>
                </div>
                <div class="info-box">
                    <div class="stat-label">DIST</div>
                    <div class="stat-value" id="dist-disp">0m</div>
                </div>
            </div>

            <div id="wind-indicator">
                <div class="stat-label" style="margin-top:-20px; position:absolute;">WIND</div>
                <div id="wind-bar"></div>
            </div>

            <div id="reload-indicator">CHAMBERING...</div>
            
            <!-- Scope Visuals -->
            <div id="scope-overlay"></div>
            <div id="crosshair">
                <svg width="60" height="60" viewBox="0 0 60 60">
                    <line x1="0" y1="30" x2="60" y2="30" stroke="#00ff41" stroke-width="1" />
                    <line x1="30" y1="0" x2="30" y2="60" stroke="#00ff41" stroke-width="1" />
                    <circle cx="30" cy="30" r="20" stroke="#00ff41" stroke-width="1" fill="none" opacity="0.5"/>
                    <!-- Mil-dots -->
                    <circle cx="40" cy="30" r="1" fill="#00ff41" />
                    <circle cx="50" cy="30" r="1" fill="#00ff41" />
                    <circle cx="20" cy="30" r="1" fill="#00ff41" />
                    <circle cx="10" cy="30" r="1" fill="#00ff41" />
                </svg>
            </div>
        </div>

        <!-- Mobile Controls -->
        <div id="aim-pad"></div>
        <div id="mobile-controls">
            <div class="touch-btn" id="btn-scope">SCOPE</div>
            <div class="touch-btn" id="btn-steady" style="border-color: yellow; color: yellow;">HOLD</div>
            <div class="touch-btn" id="btn-fire" style="border-color: red; color: red;">FIRE</div>
        </div>

        <!-- Menus -->
        <div id="startMenu" class="menu-screen">
            <h1 style="font-family: 'Black Ops One'; font-size: 40px; margin-bottom: 10px;">NIGHTFALL</h1>
            <p style="margin-bottom: 20px; color: #fff;">Eliminate High-Value Targets</p>
            <div style="font-size: 12px; text-align: left; margin-bottom: 20px; color: #ccc;">
                • Compensate for WIND and GRAVITY.<br>
                • Headshots for instant kill.<br>
                • Hold SHIFT/BTN to steady aim.<br>
            </div>
            <button class="btn" onclick="Game.start()">DEPLOY</button>
        </div>

        <div id="gameOver" class="menu-screen" style="display: none;">
            <h1 id="go-title" style="font-family: 'Black Ops One'">MISSION ACCOMPLISHED</h1>
            <div id="go-stats" style="margin: 20px 0; font-family: monospace;"></div>
            <button class="btn" onclick="Game.nextLevel()">NEXT OP</button>
        </div>
    </div>

    <script>
        // --- ENGINE CONSTANTS & UTILS ---
        const C = {
            GRAVITY: 0.08,
            MUZZLE_VELOCITY: 25,
            SCOPE_ZOOM: 2.5,
            BOLT_TIME: 1500,
            BREATH_MAX: 100,
            BREATH_DRAIN: 0.8,
            BREATH_RECOV: 0.4,
            SWAY_BASE: 0.5,
            SWAY_STEADY: 0.05
        };

        const Utils = {
            dist: (x1, y1, x2, y2) => Math.sqrt((x2-x1)**2 + (y2-y1)**2),
            rand: (min, max) => Math.random() * (max - min) + min,
            clamp: (val, min, max) => Math.min(Math.max(val, min), max)
        };

        // --- GAME CLASSES ---

        class Particle {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.life = 1.0;
                this.type = type; // 'blood', 'spark', 'smoke', 'casing'
                
                if (type === 'casing') {
                    this.vx = Utils.rand(2, 5);
                    this.vy = Utils.rand(-4, -8);
                    this.rot = 0;
                    this.rotSpeed = Utils.rand(-0.2, 0.2);
                } else {
                    const speed = type === 'blood' ? 2 : 0.5;
                    const angle = Utils.rand(0, Math.PI * 2);
                    this.vx = Math.cos(angle) * speed;
                    this.vy = Math.sin(angle) * speed;
                }
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= 0.02;

                if (this.type === 'casing') {
                    this.vy += 0.5; // Gravity
                    this.rot += this.rotSpeed;
                    if (this.life < 0.5) this.life = 0; // Disappear faster
                } else {
                    this.vx *= 0.95;
                    this.vy *= 0.95;
                }
            }

            draw(ctx) {
                ctx.globalAlpha = this.life;
                if (this.type === 'blood') {
                    ctx.fillStyle = '#8a0303';
                    ctx.beginPath(); ctx.arc(this.x, this.y, Utils.rand(1, 3), 0, Math.PI*2); ctx.fill();
                } else if (this.type === 'spark') {
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(this.x, this.y, 2, 2);
                } else if (this.type === 'casing') {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.rot);
                    ctx.fillStyle = '#d4af37'; // Gold
                    ctx.fillRect(-3, -1, 6, 2);
                    ctx.restore();
                }
                ctx.globalAlpha = 1;
            }
        }

        class Target {
            constructor(w, h, level) {
                this.w = w;
                this.h = h;
                this.reset(level);
            }

            reset(level) {
                // Further targets = smaller visually, represented by Z depth
                this.z = Utils.rand(1, 3); // Depth factor (1 = close, 3 = far)
                this.scale = 1 / this.z;
                
                // Position within "world" bounds
                this.worldX = Utils.rand(this.w * -0.5, this.w * 0.5);
                this.worldY = Utils.rand(this.h * -0.2, this.h * 0.2);
                
                this.speed = (Utils.rand(0.5, 1.5) + (level * 0.2)) * (Math.random() > 0.5 ? 1 : -1);
                this.patrolRange = Utils.rand(100, 300);
                this.startX = this.worldX;
                
                this.alive = true;
                this.health = 100;
                
                // Dimensions
                this.width = 30 * this.scale;
                this.height = 70 * this.scale;
                this.headRad = 8 * this.scale;
            }

            update() {
                if (!this.alive) return;
                
                // Patrol logic
                this.worldX += this.speed * 0.5; // Slower movement at distance
                if (Math.abs(this.worldX - this.startX) > this.patrolRange) {
                    this.speed *= -1;
                }
            }

            draw(ctx, camX, camY, zoom) {
                if (!this.alive) return;

                // Calculate screen position based on camera and zoom
                const screenX = (this.worldX - camX) * zoom + ctx.canvas.width/2;
                const screenY = (this.worldY - camY) * zoom + ctx.canvas.height/2;
                
                const drawScale = this.scale * zoom;

                // Don't draw if off screen
                if (screenX < -100 || screenX > ctx.canvas.width + 100) return;

                // Draw Enemy (Thermal/Night Vision Style)
                ctx.save();
                ctx.shadowBlur = 10;
                ctx.shadowColor = 'rgba(0, 255, 0, 0.5)';
                ctx.fillStyle = '#003300'; // Dark green fill
                ctx.strokeStyle = '#00ff41'; // Bright outline
                
                // Body
                const bW = 30 * drawScale;
                const bH = 50 * drawScale;
                ctx.fillRect(screenX - bW/2, screenY, bW, bH);
                ctx.strokeRect(screenX - bW/2, screenY, bW, bH);

                // Head
                const hR = 10 * drawScale;
                ctx.beginPath();
                ctx.arc(screenX, screenY - hR, hR, 0, Math.PI*2);
                ctx.fill();
                ctx.stroke();

                // Hitbox storage for bullet check (Screen coords)
                this.hitbox = { 
                    x: screenX, 
                    y: screenY, 
                    bodyW: bW, 
                    bodyH: bH, 
                    headR: hR 
                };
                ctx.restore();
            }

            checkHit(bx, by) {
                if (!this.alive || !this.hitbox) return false;
                
                const h = this.hitbox;
                
                // Check Head
                const distHead = Utils.dist(bx, by, h.x, h.y - h.headR);
                if (distHead < h.headR * 1.5) return 'HEADSHOT'; // Generous hitbox

                // Check Body
                if (bx > h.x - h.bodyW/2 && bx < h.x + h.bodyW/2 &&
                    by > h.y && by < h.y + h.bodyH) {
                    return 'BODY';
                }
                return false;
            }
        }

        // --- MAIN GAME ENGINE ---
        const Game = {
            canvas: document.getElementById('gameCanvas'),
            ctx: document.getElementById('gameCanvas').getContext('2d', { alpha: false }),
            
            state: {
                active: false,
                level: 1,
                targets: [],
                particles: [],
                bullets: [],
                
                // Camera/Aiming
                camX: 0,
                camY: 0,
                aimX: 0, // Mouse/Touch input X
                aimY: 0, // Mouse/Touch input Y
                
                // Mechanics
                isScoped: false,
                canShoot: true,
                wind: 0,
                breath: 100,
                isHoldingBreath: false,
                
                stats: { shots: 0, hits: 0, headshots: 0 }
            },

            input: { x: 0, y: 0, holding: false },

            init() {
                this.resize();
                window.addEventListener('resize', () => this.resize());
                
                // Inputs
                document.addEventListener('mousemove', e => this.handleMouseMove(e));
                document.addEventListener('mousedown', e => { if(e.button === 0) this.shoot(); if(e.button === 2) this.toggleScope(); });
                document.addEventListener('mouseup', () => this.state.isHoldingBreath = false);
                document.addEventListener('contextmenu', e => e.preventDefault());
                document.addEventListener('keydown', e => { if(e.code === 'ShiftLeft') this.state.isHoldingBreath = true; });
                document.addEventListener('keyup', e => { if(e.code === 'ShiftLeft') this.state.isHoldingBreath = false; });

                // Touch Inputs
                const pad = document.getElementById('aim-pad');
                let touchStart = {x:0, y:0};
                
                pad.addEventListener('touchstart', e => {
                    touchStart.x = e.touches[0].clientX;
                    touchStart.y = e.touches[0].clientY;
                }, {passive: false});
                
                pad.addEventListener('touchmove', e => {
                    e.preventDefault();
                    const dx = (e.touches[0].clientX - touchStart.x) * 1.5; // Sensitivity
                    const dy = (e.touches[0].clientY - touchStart.y) * 1.5;
                    
                    this.state.aimX += dx;
                    this.state.aimY += dy;
                    
                    // Clamp aim
                    const limitX = this.canvas.width/2;
                    const limitY = this.canvas.height/2;
                    this.state.aimX = Utils.clamp(this.state.aimX, -limitX, limitX);
                    this.state.aimY = Utils.clamp(this.state.aimY, -limitY, limitY);

                    touchStart.x = e.touches[0].clientX;
                    touchStart.y = e.touches[0].clientY;
                }, {passive: false});

                document.getElementById('btn-fire').addEventListener('touchstart', (e) => { e.preventDefault(); this.shoot(); });
                document.getElementById('btn-scope').addEventListener('touchstart', (e) => { e.preventDefault(); this.toggleScope(); });
                document.getElementById('btn-steady').addEventListener('touchstart', (e) => { e.preventDefault(); this.state.isHoldingBreath = true; });
                document.getElementById('btn-steady').addEventListener('touchend', (e) => { e.preventDefault(); this.state.isHoldingBreath = false; });

                this.loop();
            },

            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            },

            start() {
                document.getElementById('startMenu').style.display = 'none';
                document.getElementById('gameOver').style.display = 'none';
                this.state.active = true;
                this.state.level = 1;
                this.state.stats = { shots: 0, hits: 0, headshots: 0 };
                this.loadLevel();
            },

            loadLevel() {
                this.state.targets = [];
                this.state.bullets = [];
                this.state.particles = [];
                
                // Difficulty scaling
                const count = 2 + this.state.level;
                this.state.wind = Utils.rand(-2, 2) * (this.state.level * 0.5);
                
                for(let i=0; i<count; i++) {
                    this.state.targets.push(new Target(this.canvas.width * 2, this.canvas.height, this.state.level));
                }

                // UI Updates
                document.getElementById('mission-disp').innerText = this.state.level.toString().padStart(2, '0');
                this.updateUI();
                
                // Wind UI
                const windPct = 50 + (this.state.wind * 20);
                document.getElementById('wind-bar').style.width = `${Utils.clamp(windPct, 10, 90)}%`;
                document.getElementById('wind-bar').style.background = Math.abs(this.state.wind) > 1 ? 'red' : '#00ff41';
            },

            handleMouseMove(e) {
                if (!this.state.active) return;
                // Map mouse to relative aim coordinates (-width/2 to width/2)
                this.state.aimX = e.clientX - this.canvas.width/2;
                this.state.aimY = e.clientY - this.canvas.height/2;
            },

            toggleScope() {
                this.state.isScoped = !this.state.isScoped;
                document.getElementById('scope-overlay').style.opacity = this.state.isScoped ? 1 : 0;
                document.getElementById('crosshair').style.transform = `translate(-50%, -50%) scale(${this.state.isScoped ? 2 : 1})`;
            },

            shoot() {
                if (!this.state.active || !this.state.canShoot) return;

                this.state.canShoot = false;
                this.state.stats.shots++;
                
                // Recoil visual
                document.getElementById('gameContainer').style.animation = 'none';
                void document.getElementById('gameContainer').offsetWidth; // trigger reflow
                document.getElementById('gameContainer').style.animation = 'recoil 0.2s ease-out';

                // Create Bullet
                // Origin is center screen. 
                // Velocity includes wind physics
                const center = { x: this.canvas.width/2, y: this.canvas.height/2 };
                
                this.state.bullets.push({
                    x: center.x,
                    y: center.y,
                    vx: (this.state.wind * 0.5), // Initial wind drift
                    vy: 0,
                    life: 100,
                    drop: 0
                });

                // Muzzle Flash Particles
                for(let i=0; i<10; i++) this.state.particles.push(new Particle(center.x, center.y + 20, 'spark'));
                
                // Shell Casing (Eject from right)
                const casing = new Particle(this.canvas.width - 100, this.canvas.height - 50, 'casing');
                this.state.particles.push(casing);

                // Bolt Action Timer
                document.getElementById('reload-indicator').style.display = 'block';
                setTimeout(() => {
                    this.state.canShoot = true;
                    document.getElementById('reload-indicator').style.display = 'none';
                }, C.BOLT_TIME);
            },

            update() {
                if (!this.state.active) return;

                // 1. Breathing & Sway Logic
                if (this.state.isHoldingBreath && this.state.breath > 0) {
                    this.state.breath -= C.BREATH_DRAIN;
                    var currentSway = C.SWAY_STEADY;
                } else {
                    this.state.breath = Math.min(this.state.breath + C.BREATH_RECOV, C.BREATH_MAX);
                    var currentSway = C.SWAY_BASE;
                    this.state.isHoldingBreath = false; // Force stop if empty
                }
                
                // Procedural Sway (Perlin-ish noise via sin)
                const time = Date.now() / 1000;
                const swayX = Math.sin(time) * currentSway * (this.state.isScoped ? 5 : 20);
                const swayY = Math.cos(time * 0.8) * currentSway * (this.state.isScoped ? 5 : 20);

                // 2. Camera Movement
                // The camera follows the player's aim, but smoother
                let targetCamX = this.state.aimX + swayX;
                let targetCamY = this.state.aimY + swayY;
                
                this.state.camX += (targetCamX - this.state.camX) * 0.1;
                this.state.camY += (targetCamY - this.state.camY) * 0.1;

                // 3. Update Entities
                this.state.targets.forEach(t => t.update());
                this.state.particles.forEach((p, i) => {
                    p.update();
                    if (p.life <= 0) this.state.particles.splice(i, 1);
                });

                // 4. Bullet Physics
                this.state.bullets.forEach((b, i) => {
                    // Move "forward" into the screen (Z-depth simulation) by not changing X/Y much,
                    // but we simulate bullet travel by checking hitscan over frames or actual projectile.
                    // Let's do semi-fast projectile.
                    
                    b.life--;
                    
                    // Wind and Gravity effect
                    b.x += b.vx; // Wind drift
                    b.drop += C.GRAVITY; // Gravity velocity
                    b.y += b.drop;
                    
                    // Check collisions
                    let hit = false;
                    for(let t of this.state.targets) {
                        if(!t.alive) continue;
                        const result = t.checkHit(b.x, b.y);
                        if(result) {
                            t.alive = false;
                            t.health = 0;
                            hit = true;
                            this.state.stats.hits++;
                            if(result === 'HEADSHOT') this.state.stats.headshots++;
                            
                            // Blood
                            for(let k=0; k<15; k++) this.state.particles.push(new Particle(b.x, b.y, 'blood'));
                            break;
                        }
                    }

                    if (hit || b.life <= 0) {
                        this.state.bullets.splice(i, 1);
                    }
                });

                // Check Level Complete
                const alive = this.state.targets.filter(t => t.alive).length;
                if (alive === 0) {
                    setTimeout(() => this.levelComplete(), 1000);
                }
                
                this.updateUI();
            },

            draw() {
                // Background (Night Vision Noise)
                this.ctx.fillStyle = '#020502';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Grid Lines (Perspective illusion)
                this.ctx.strokeStyle = '#003300';
                this.ctx.lineWidth = 1;
                const offsetX = (this.state.camX * -0.1) % 50;
                const offsetY = (this.state.camY * -0.1) % 50;
                
                this.ctx.beginPath();
                for(let x=0; x<this.canvas.width; x+=100) {
                    this.ctx.moveTo(x + offsetX, 0); this.ctx.lineTo(x + offsetX, this.canvas.height);
                }
                for(let y=0; y<this.canvas.height; y+=100) {
                    this.ctx.moveTo(0, y + offsetY); this.ctx.lineTo(this.canvas.width, y + offsetY);
                }
                this.ctx.stroke();

                // Draw World
                const zoom = this.state.isScoped ? C.SCOPE_ZOOM : 1.0;
                
                // Draw Targets
                // Sort by Z (simple painter's alg, though Z is stored in scale)
                this.state.targets.sort((a,b) => a.scale - b.scale).forEach(t => t.draw(this.ctx, this.state.camX, this.state.camY, zoom));

                // Draw Bullets
                this.ctx.fillStyle = '#ffff00';
                this.state.bullets.forEach(b => {
                    // Bullet gets smaller as it goes "away" (life decreases)
                    const s = Math.max(2, (b.life/100) * 5);
                    this.ctx.fillRect(b.x - s/2, b.y - s/2, s, s);
                });

                // Draw Particles
                this.state.particles.forEach(p => p.draw(this.ctx));

                // Breath Bar (Visual near crosshair)
                if (this.state.active) {
                    const cx = this.canvas.width/2;
                    const cy = this.canvas.height/2 + 50;
                    this.ctx.fillStyle = 'rgba(0,0,0,0.5)';
                    this.ctx.fillRect(cx - 50, cy, 100, 4);
                    this.ctx.fillStyle = this.state.breath < 30 ? '#ff3333' : '#00ff41';
                    this.ctx.fillRect(cx - 50, cy, this.state.breath, 4);
                }
            },

            updateUI() {
                const alive = this.state.targets.filter(t => t.alive).length;
                const total = this.state.targets.length;
                document.getElementById('target-disp').innerText = `${total - alive}/${total}`;
                
                // Mock distance calculation based on scope and aim Y (looking "down" = closer)
                const dist = Math.floor(150 + (this.state.aimY * -0.2)); 
                document.getElementById('dist-disp').innerText = dist + 'm';
            },

            levelComplete() {
                this.state.active = false;
                document.getElementById('gameOver').style.display = 'block';
                
                // Calc Rating
                const acc = this.state.stats.hits / this.state.stats.shots || 0;
                let rank = 'C';
                if (acc > 0.8 && this.state.stats.headshots > 0) rank = 'S';
                else if (acc > 0.6) rank = 'A';
                else if (acc > 0.4) rank = 'B';

                document.getElementById('go-stats').innerHTML = `
                    TARGETS ELIMINATED<br><br>
                    ACCURACY: ${(acc*100).toFixed(0)}%<br>
                    HEADSHOTS: ${this.state.stats.headshots}<br>
                    RANK: <span style="color:${rank==='S'?'gold':'var(--hud-color)'}; font-size:24px">${rank}</span>
                `;
            },

            nextLevel() {
                this.state.level++;
                document.getElementById('gameOver').style.display = 'none';
                this.state.active = true;
                this.loadLevel();
            },

            loop() {
                requestAnimationFrame(() => this.loop());
                this.update();
                this.draw();
            }
        };

        // Init
        window.onload = () => Game.init();
    </script>
</body>
</html>
