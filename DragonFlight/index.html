<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Dragon Flight â€” Endless Adventure</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    :root {
      --ui: #9cf8ff;
      --accent: #ffd166;
      --bg: #0b0f1a;
      --good: #73fa88;
      --bad: #ff6b6b;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: radial-gradient(1200px 500px at 50% -20%, #15203a, var(--bg));
      color: var(--ui);
      font-family: 'Press Start 2P', system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
      overflow: hidden;
    }

    #game { position: relative; width: 100vw; height: 100vh; }
    canvas { display: block; width: 100%; height: 100%; }

    /* HUD */
    .hud {
      position: absolute;
      top: 0; left: 0; right: 0;
      display: flex; align-items: center; justify-content: space-between;
      gap: 16px;
      padding: clamp(10px, 2vw, 20px);
      pointer-events: none;
    }
    .hud .stats { display: flex; gap: clamp(10px, 4vw, 32px); }
    .panel {
      background: rgba(10, 15, 28, 0.45);
      border: 1px solid rgba(156, 248, 255, 0.35);
      box-shadow: 0 0 24px rgba(156, 248, 255, 0.12) inset, 0 0 20px rgba(0,0,0,0.3);
      border-radius: 10px;
      padding: 10px 14px;
      text-shadow: 0 0 8px rgba(156, 248, 255, 0.6);
      pointer-events: none;
    }
    .title { font-size: clamp(12px, 2.4vw, 18px); letter-spacing: 1px; }
    .value { font-size: clamp(16px, 4.2vw, 28px); color: white; display: block; margin-top: 6px; }

    /* Start and Game Over overlays */
    .overlay {
      position: absolute; inset: 0; display: grid; place-items: center; text-align: center;
      background: radial-gradient(1000px 400px at 50% 0%, rgba(30,40,70,0.5), rgba(10,10,18,0.85));
      color: var(--ui);
    }
    .card {
      max-width: 680px; width: min(92vw, 680px);
      padding: 28px clamp(16px, 4vw, 40px);
      border: 1px solid rgba(156, 248, 255, 0.35);
      border-radius: 14px;
      background: rgba(10, 15, 28, 0.7);
      box-shadow: 0 0 28px rgba(156, 248, 255, 0.18), inset 0 0 24px rgba(156, 248, 255, 0.12);
    }
    .card h1 { margin: 0 0 14px; font-size: clamp(22px, 5vw, 36px); color: white; }
    .card p { margin: 6px 0; line-height: 1.6; font-size: clamp(10px, 2.3vw, 14px); opacity: 0.9; }
    .controls { margin-top: 14px; font-size: clamp(10px, 2.3vw, 14px); color: var(--accent); }
    .button {
      margin-top: 18px;
      display: inline-block; pointer-events: auto;
      padding: 12px 18px;
      border-radius: 12px;
      border: 1px solid rgba(255, 209, 102, 0.5);
      background: linear-gradient(180deg, rgba(255, 209, 102, 0.95), rgba(255, 156, 54, 0.95));
      color: #111; text-decoration: none;
      text-shadow: none;
      transition: transform .08s;
    }
    .button:active { transform: translateY(1px); }

    .hidden { display: none; }

    /* Touch hint */
    .hint { position: absolute; bottom: 12px; left: 50%; transform: translateX(-50%); font-size: 10px; opacity: .7; }

    /* Scanlines for retro feel */
    #game::after {
      content: ""; position: absolute; inset: 0; pointer-events: none;
      background: linear-gradient(transparent 50%, rgba(255,255,255,0.05) 50%);
      background-size: 100% 4px; mix-blend-mode: overlay; opacity: .2;
    }
  </style>
</head>
<body>
  <div id="game">
    <canvas id="c"></canvas>

    <div class="hud">
      <div class="panel">
        <span class="title">SCORE</span>
        <span id="score" class="value">0000</span>
      </div>
      <div class="stats">
        <div class="panel">
          <span class="title">BEST</span>
          <span id="best" class="value">0000</span>
        </div>
        <div class="panel">
          <span class="title">SHIELD</span>
          <span id="shield" class="value">OFF</span>
        </div>
      </div>
    </div>

    <div id="start" class="overlay">
      <div class="card">
        <h1>DRAGON FLIGHT</h1>
        <p>Fly through the ancient caves. Collect gems. Avoid spikes. Grab shields to survive a hit. Simple, fast, and retro.</p>
        <p class="controls">Press Space or click/tap to flap. Press P to pause. Survive as long as you can.</p>
        <a class="button" id="playBtn" href="#">Start Flight</a>
      </div>
      <div class="hint">Tip: stay low when you see tall ceiling spikes</div>
    </div>

    <div id="over" class="overlay hidden">
      <div class="card">
        <h1>Flight Over</h1>
        <p>Your score: <span id="final">0</span></p>
        <p>Best: <span id="finalBest">0</span></p>
        <a class="button" id="againBtn" href="#">Fly Again</a>
      </div>
    </div>
  </div>

  <script>
  (() => {
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');

    // HUD elements
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const shieldEl = document.getElementById('shield');
    const startEl = document.getElementById('start');
    const overEl = document.getElementById('over');
    const finalEl = document.getElementById('final');
    const finalBestEl = document.getElementById('finalBest');
    const playBtn = document.getElementById('playBtn');
    const againBtn = document.getElementById('againBtn');

    // Game state
    let W = 0, H = 0, dpr = 1;
    let running = false; let paused = false; let t = 0;
    let score = 0; let best = 0;
    let objects = []; // spikes, gems, powerups
    let particles = [];
    let lastSpawnX = 0; // Track last spawn position to ensure proper spacing

    // Player dragon
    const dragon = {
      x: 160, y: 0, vx: 0, vy: 0,
      r: 20, // base radius
      flapStrength: -8.5,
      gravity: 0.45,
      shield: 0, // time remaining frames
      alive: true,
    };

    // Utility
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const rand = (a, b) => a + Math.random() * (b - a);
    const pad = (n) => String(n|0).padStart(4, '0');

    function resize() {
      dpr = window.devicePixelRatio || 1;
      W = canvas.width = Math.floor(window.innerWidth * dpr);
      H = canvas.height = Math.floor(window.innerHeight * dpr);
      canvas.style.width = '100%';
      canvas.style.height = '100%';
    }
    window.addEventListener('resize', resize);

    function loadBest() {
      try { best = parseInt(localStorage.getItem('dragonFlightBest') || '0', 10) || 0; } catch(e){ best = 0; }
      bestEl.textContent = pad(best);
    }
    function saveBest() { try { localStorage.setItem('dragonFlightBest', String(best)); } catch(e){} }

    // Input
    function flap() {
      if (!running) { start(); return; }
      if (!dragon.alive) return;
      dragon.vy = dragon.flapStrength;
      // small horizontal bob for feel
      dragon.vx = 0.6;
      spawnFlapBurst();
    }

    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space') { e.preventDefault(); flap(); }
      if (e.code === 'KeyP') { e.preventDefault(); if (running) paused = !paused; }
    }, { passive: false });

    canvas.addEventListener('pointerdown', flap);
    playBtn.addEventListener('click', (e) => { e.preventDefault(); start(); });
    againBtn.addEventListener('click', (e) => { e.preventDefault(); reset(); start(); });

    // Generators - FIXED SPACING (SIMPLIFIED)
    let spawnTimer = 0;
    
    function spawnStuff(dt) {
      spawnTimer += dt;
      
      // Determine spawn interval based on difficulty
      const baseInterval = 1200; // Base spawn time in ms
      const minInterval = 700; // Minimum spawn time
      const difficultyReduction = Math.min(400, score * 0.6);
      const spawnInterval = Math.max(minInterval, baseInterval - difficultyReduction);
      
      if (spawnTimer < spawnInterval) return;
      spawnTimer = 0;

      // Simple but effective spacing
      const speed = getSpeed();
      const minSpacing = 300 * dpr; // Fixed minimum spacing in pixels
      
      // Find rightmost obstacle
      let rightmostX = W + 50 * dpr; // Default spawn position
      for (const obj of objects) {
        const objRight = obj.x + (obj.type === 'spike' ? obj.w : obj.r * 2);
        if (objRight > rightmostX - minSpacing) {
          rightmostX = objRight + minSpacing;
        }
      }
      
      const spawnX = rightmostX;

      // Decide what to spawn: spikes pair, gem, or shield
      const roll = Math.random();

      if (roll < 0.65) {
        // Spike pair
        const gap = clamp(150 - score * 0.05, 120, 150) * dpr;
        const topHeight = rand(60, H*0.42 - gap*0.5);
        const bottomStart = topHeight + gap;
        const thickness = rand(22, 32) * dpr;
        const color = `hsl(${220 + rand(-10, 10)}, 70%, 65%)`;
        
        objects.push({ 
          type: 'spike', 
          x: spawnX, 
          y: 0, 
          w: thickness, 
          h: topHeight, 
          vx: -speed, 
          color
        });
        objects.push({ 
          type: 'spike', 
          x: spawnX, 
          y: bottomStart, 
          w: thickness, 
          h: H - bottomStart, 
          vx: -speed, 
          color
        });
        
      } else if (roll < 0.88) {
        // Gem - spawn with small offset
        const gemX = spawnX + rand(60, 120) * dpr;
        const safeY = rand(H*0.25, H*0.75);
        objects.push({ 
          type: 'gem', 
          x: gemX,
          y: safeY, 
          r: 10 * dpr, 
          vx: -speed*0.95, 
          bob: rand(0, 6.28)
        });
        
      } else {
        // Shield power-up
        const shieldX = spawnX + rand(80, 150) * dpr;
        const safeY = rand(H*0.3, H*0.7);
        objects.push({ 
          type: 'shield', 
          x: shieldX,
          y: safeY, 
          r: 13 * dpr, 
          vx: -speed*0.9, 
          bob: rand(0, 6.28)
        });
      }
    }

    function getSpeed() {
      return (2.4 + Math.min(5, score * 0.002)) * dpr; // Even slower, more controlled speed
    }

    // Particles
    function addParticle(px, py, vx, vy, life, color, size) {
      particles.push({ x: px, y: py, vx, vy, life, max: life, color, size });
    }

    function spawnFlapBurst() {
      const n = 12;
      for (let i=0;i<n;i++) {
        const a = rand(Math.PI*0.8, Math.PI*1.2);
        const s = rand(1.2, 2.8) * dpr;
        addParticle(dragon.x - dragon.r*0.8, dragon.y + rand(-6,6)*dpr, Math.cos(a)*s, Math.sin(a)*s, rand(300, 520), 'rgba(255,240,180,0.8)', rand(2,4)*dpr);
      }
    }

    function spawnHitBurst() {
      const n = 22;
      for (let i=0;i<n;i++) {
        const a = rand(0, Math.PI*2);
        const s = rand(1.5, 3.6) * dpr;
        addParticle(dragon.x, dragon.y, Math.cos(a)*s, Math.sin(a)*s, rand(400, 700), 'rgba(255,90,90,0.9)', rand(2,5)*dpr);
      }
    }

    // Collision helpers
    function circleRectCollide(cx, cy, cr, rx, ry, rw, rh) {
      const nx = clamp(cx, rx, rx + rw);
      const ny = clamp(cy, ry, ry + rh);
      const dx = cx - nx; const dy = cy - ny;
      return dx*dx + dy*dy <= cr*cr;
    }

    function circleCircleCollide(ax, ay, ar, bx, by, br) {
      const dx = ax - bx, dy = ay - by, r = ar + br; return dx*dx + dy*dy <= r*r;
    }

    // Drawing
    function drawBackground(time) {
      // parallax caves and stars
      const speed = getSpeed();
      const tpx = (time * 0.04 * speed) % (W);

      // Stars
      ctx.save();
      ctx.globalAlpha = 0.5;
      for (let i=0;i<80;i++) {
        const x = (i*W/80 - tpx*0.4 + W) % W;
        const y = (i*i*97 % H);
        ctx.fillStyle = i % 7 ? 'rgba(180,220,255,0.5)' : 'rgba(255,255,255,0.9)';
        ctx.fillRect(x, y, 2*dpr, 2*dpr);
      }
      ctx.restore();

      // Layered cave silhouettes
      const layers = [
        { h: H*0.72, amp: 28*dpr, k: 0.0016, a: 0.7 },
        { h: H*0.80, amp: 34*dpr, k: 0.0012, a: 0.6 },
        { h: H*0.88, amp: 40*dpr, k: 0.0010, a: 0.5 },
      ];
      layers.forEach((L, idx) => {
        const yBase = L.h;
        ctx.fillStyle = `rgba(35,50,85,${L.a})`;
        ctx.beginPath();
        ctx.moveTo(0, H);
        for (let x=0; x<=W; x+=8*dpr) {
          const y = yBase + Math.sin((x + tpx*(0.4+idx*0.25)) * L.k) * L.amp;
          ctx.lineTo(x, y);
        }
        ctx.lineTo(W, H); ctx.closePath(); ctx.fill();
      });

      // Ceiling silhouette
      ctx.fillStyle = 'rgba(25,40,70,0.6)';
      ctx.beginPath(); ctx.moveTo(0,0);
      for (let x=0; x<=W; x+=8*dpr) {
        const y = 40*dpr + Math.sin((x + tpx*0.55) * 0.002) * 20*dpr;
        ctx.lineTo(x, y);
      }
      ctx.lineTo(W,0); ctx.closePath(); ctx.fill();
    }

    function drawDragon() {
      const x = dragon.x, y = dragon.y, r = dragon.r;
      // body
      const tilt = clamp(dragon.vy * 0.04, -0.6, 0.6);
      ctx.save();
      ctx.translate(x, y); ctx.rotate(tilt);

      // tail
      ctx.fillStyle = '#e2a23a';
      ctx.beginPath();
      ctx.moveTo(-r*1.2, 0);
      ctx.quadraticCurveTo(-r*1.6, -r*0.3, -r*2.0, 0);
      ctx.quadraticCurveTo(-r*1.6, r*0.3, -r*1.2, 0);
      ctx.fill();

      // wings (flap)
      const wing = Math.sin(t * 0.02) * r*0.5 + r*0.7;
      ctx.fillStyle = '#f8d27a';
      ctx.beginPath();
      ctx.ellipse(-r*0.2, -r*0.6, wing*0.7, r*0.5, -0.3, 0, Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(-r*0.2, r*0.6, wing*0.7, r*0.5, 0.3, 0, Math.PI*2);
      ctx.fill();

      // body core
      const grad = ctx.createRadialGradient(0,0,r*0.2, 0,0,r*1.05);
      grad.addColorStop(0,'#fff5cc'); grad.addColorStop(1,'#e5b757');
      ctx.fillStyle = grad;
      ctx.beginPath(); ctx.ellipse(0,0,r*1.15,r*0.9,0,0,Math.PI*2); ctx.fill();

      // eye
      ctx.fillStyle = '#222'; ctx.beginPath(); ctx.arc(r*0.5,-r*0.15,r*0.12,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(r*0.55,-r*0.18,r*0.05,0,Math.PI*2); ctx.fill();

      // shield glow
      if (dragon.shield > 0) {
        ctx.shadowColor = 'rgba(115,250,136,0.9)';
        ctx.shadowBlur = 18*dpr;
        ctx.strokeStyle = 'rgba(115,250,136,0.9)';
        ctx.lineWidth = 3*dpr;
        ctx.beginPath(); ctx.arc(0,0,r*1.4,0,Math.PI*2); ctx.stroke();
      }

      ctx.restore();
    }

    function drawObjects() {
      for (const o of objects) {
        if (o.type === 'spike') {
          ctx.fillStyle = o.color;
          // draw as jagged crystal column
          ctx.beginPath();
          const x = o.x, y = o.y, w = o.w, h = o.h;
          const teeth = Math.max(4, Math.floor(h / (24*dpr)));
          const step = h / teeth;
          for (let i=0;i<teeth;i++) {
            const yy = y + i*step;
            const skew = (i % 2 ? -1 : 1) * w*0.35;
            ctx.moveTo(x, yy);
            ctx.lineTo(x + w, yy);
            ctx.lineTo(x + w + skew, yy + step);
            ctx.lineTo(x + skew, yy + step);
          }
          ctx.closePath(); ctx.fill();
        } else if (o.type === 'gem') {
          const r = o.r; const pulse = 1 + Math.sin(t*0.02 + o.bob) * 0.08;
          ctx.save(); ctx.translate(o.x, o.y); ctx.scale(pulse, pulse);
          const g = ctx.createLinearGradient(-r, -r, r, r);
          g.addColorStop(0, '#6cf'); g.addColorStop(1, '#c8f7ff');
          ctx.fillStyle = g; ctx.strokeStyle = 'rgba(255,255,255,0.7)'; ctx.lineWidth = 1*dpr;
          ctx.beginPath();
          ctx.moveTo(0,-r); ctx.lineTo(r*0.8, -r*0.2); ctx.lineTo(r*0.6, r*0.9);
          ctx.lineTo(-r*0.6, r*0.9); ctx.lineTo(-r*0.8, -r*0.2); ctx.closePath();
          ctx.fill(); ctx.stroke();
          ctx.restore();
        } else if (o.type === 'shield') {
          const r = o.r; const pulse = 1 + Math.sin(t*0.03 + o.bob) * 0.12;
          ctx.save(); ctx.translate(o.x, o.y); ctx.scale(pulse, pulse);
          ctx.strokeStyle = 'rgba(115,250,136,0.95)'; ctx.lineWidth = 2*dpr;
          ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(0,-r*0.6); ctx.lineTo(0,r*0.6); ctx.stroke();
          ctx.restore();
        }
      }
    }

    function drawParticles(dt) {
      for (const p of particles) {
        const a = p.life / p.max;
        ctx.globalAlpha = a;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, p.size, p.size);
        ctx.globalAlpha = 1;
      }
    }

    // Update
    let last = performance.now();
    function update() {
      const now = performance.now();
      let dt = now - last; if (dt > 80) dt = 80; // clamp
      last = now; if (!running || paused) { requestAnimationFrame(update); return drawFrame(0); }
      t += dt;

      // Physics
      dragon.vy += dragon.gravity * dpr;
      dragon.y += dragon.vy * dpr;
      dragon.x += dragon.vx * dpr; dragon.vx *= 0.92;

      // World bounds
      dragon.y = clamp(dragon.y, dragon.r + 4*dpr, H - dragon.r - 4*dpr);

      // Spawn and move objects
      spawnStuff(dt);
      const speed = getSpeed();
      for (let i=objects.length-1; i>=0; i--) {
        const o = objects[i];
        o.x += o.vx;
        if (o.type === 'gem' || o.type === 'shield') {
          o.y += Math.sin((t*0.006) + o.bob) * 0.6 * dpr;
        }
        // off screen - increased cleanup distance
        if (o.x < -150*dpr) objects.splice(i,1);
      }

      // Particles
      for (let i=particles.length-1; i>=0; i--) {
        const p = particles[i];
        p.x += p.vx; p.y += p.vy; p.vx *= 0.99; p.vy *= 0.99; p.life -= dt;
        if (p.life <= 0) particles.splice(i,1);
      }

      // Collisions
      for (let i=objects.length-1; i>=0; i--) {
        const o = objects[i];
        if (o.type === 'spike') {
          if (circleRectCollide(dragon.x, dragon.y, dragon.r*0.85, o.x, o.y, o.w, o.h)) {
            if (dragon.shield > 0) {
              dragon.shield = 0; shieldEl.textContent = 'OFF';
              spawnHitBurst();
              // break the spike chunk for effect
              for (let k=0;k<12;k++) addParticle(dragon.x, dragon.y, rand(-2,2)*dpr, rand(-2,2)*dpr, rand(200,500), 'rgba(255,220,120,0.9)', rand(2,4)*dpr);
              // nudge player out
              dragon.vy = -6*dpr; dragon.vx = -1.2*dpr;
              // remove this spike segment to avoid double hits
              objects.splice(i,1);
              continue;
            } else {
              dragon.alive = false; gameOver(); return;
            }
          }
        } else if (o.type === 'gem') {
          if (circleCircleCollide(dragon.x, dragon.y, dragon.r*0.9, o.x, o.y, o.r)) {
            score += 10; scoreEl.textContent = pad(score);
            for (let k=0;k<10;k++) addParticle(o.x, o.y, rand(-1.2,1.2)*dpr, rand(-1.2,1.2)*dpr, rand(250,450), 'rgba(200,245,255,0.95)', rand(2,4)*dpr);
            objects.splice(i,1);
          }
        } else if (o.type === 'shield') {
          if (circleCircleCollide(dragon.x, dragon.y, dragon.r*0.9, o.x, o.y, o.r)) {
            dragon.shield = 1; shieldEl.textContent = 'ON';
            for (let k=0;k<12;k++) addParticle(o.x, o.y, rand(-1.2,1.2)*dpr, rand(-1.2,1.2)*dpr, rand(300,500), 'rgba(115,250,136,0.95)', rand(2,4)*dpr);
            objects.splice(i,1);
          }
        }
      }

      // Passive score for survival
      score += Math.max(1, Math.floor(dt * 0.02));
      scoreEl.textContent = pad(score);

      drawFrame(dt);
      requestAnimationFrame(update);
    }

    function drawFrame(dt) {
      // clear
      ctx.clearRect(0,0,W,H);
      drawBackground(t);
      drawObjects();
      drawDragon();
      drawParticles(dt);
    }

    function start() {
      if (running) { paused = false; return; }
      running = true; startEl.classList.add('hidden'); overEl.classList.add('hidden');
      last = performance.now(); requestAnimationFrame(update);
    }

    function reset() {
      score = 0; scoreEl.textContent = pad(score);
      dragon.x = 160 * dpr; dragon.y = H*0.5; dragon.vx = 0; dragon.vy = 0; dragon.alive = true; dragon.shield = 0; shieldEl.textContent = 'OFF';
      objects = []; particles = []; spawnTimer = 0; t = 0; paused = false; nextSpawnX = 0;
    }

    function gameOver() {
      running = false;
      finalEl.textContent = score;
      if (score > best) { best = score; saveBest(); }
      bestEl.textContent = pad(best);
      finalBestEl.textContent = best;
      overEl.classList.remove('hidden');
    }

    // Boot
    function boot() {
      resize(); loadBest(); reset(); drawFrame(0);
    }
    boot();
  })();
  </script>
</body>
</html>
