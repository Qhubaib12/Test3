<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Geo Dash: Neon Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; user-select: none; }
        
        body {
            background: #050505;
            font-family: 'Orbitron', monospace;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            color: #00ffff;
        }
        
        #gameContainer {
            position: relative;
            width: 100%;
            height: 100%;
            background: #000;
        }
        
        canvas { display: block; width: 100%; height: 100%; }

        /* UI Overlay Layer */
        #uiLayer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        .score-box {
            text-align: right;
        }

        .label { font-size: 10px; color: #888; margin-bottom: 2px; }
        .value { font-size: 24px; font-weight: 900; color: #fff; }
        .highlight { color: #ffd700; text-shadow: 0 0 10px rgba(255, 215, 0, 0.5); }

        /* Modals */
        #startScreen, #gameOverScreen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            pointer-events: auto;
            transition: opacity 0.3s;
        }

        h1 {
            font-size: clamp(40px, 8vw, 80px);
            margin-bottom: 10px;
            background: linear-gradient(to bottom, #fff, #00ffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 15px rgba(0,255,255,0.5));
        }

        button {
            background: transparent;
            color: #00ffff;
            border: 2px solid #00ffff;
            padding: 15px 40px;
            font-family: 'Orbitron', monospace;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 30px;
            box-shadow: 0 0 15px rgba(0,255,255,0.2);
            transition: all 0.2s;
            text-transform: uppercase;
        }

        button:hover {
            background: #00ffff;
            color: #000;
            box-shadow: 0 0 30px rgba(0,255,255,0.6);
            transform: scale(1.05);
        }
        
        .hidden { opacity: 0; pointer-events: none; }

        /* CRT Scanline Effect */
        .scanlines {
            position: absolute; inset: 0; pointer-events: none; z-index: 10;
            background: linear-gradient(transparent 50%, rgba(0, 0, 0, 0.2) 50%);
            background-size: 100% 4px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div class="scanlines"></div>
        
        <div id="uiLayer">
            <div class="header">
                <div style="font-weight:900; font-size:24px; font-style:italic;">GEO DASH</div>
                <div class="score-box">
                    <div class="label">ATTEMPT</div>
                    <div class="value" id="scoreVal">0%</div>
                    <div style="height: 10px;"></div>
                    <div class="label">BEST</div>
                    <div class="value highlight" id="bestVal">0%</div>
                </div>
            </div>
        </div>

        <div id="startScreen">
            <h1>GEO DASH</h1>
            <p style="color:#aaa; margin-bottom:20px;">AVOID THE SPIKES</p>
            <button id="startBtn">INITIALIZE</button>
        </div>

        <div id="gameOverScreen" class="hidden">
            <h1 style="font-size: 40px; color: #ff4757; -webkit-text-fill-color: #ff4757;">CRASHED</h1>
            <div style="margin: 10px 0; font-size: 20px;">PROGRESS: <span id="finalScore" style="color:#fff">0%</span></div>
            <button id="restartBtn">RETRY</button>
        </div>
    </div>

    <script>
        /**
         * AUDIO ENGINE (Web Audio API)
         * Procedural sound generation - No external files needed
         */
        const AudioSys = {
            ctx: null,
            init: function() {
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.3;
                this.masterGain.connect(this.ctx.destination);
                this.startMusic();
            },
            playTone: function(freq, type, duration, decay = true) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                if (decay) {
                    gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                } else {
                    gain.gain.value = 0.05;
                }
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },
            jump: function() { this.playTone(150, 'square', 0.1); },
            death: function() { 
                this.playTone(100, 'sawtooth', 0.5); 
                this.playTone(50, 'square', 0.5); 
            },
            startMusic: function() {
                // Simple procedural bassline
                let note = 0;
                const notes = [55, 55, 55, 65, 55, 55, 82, 73];
                setInterval(() => {
                    if(gameState === 'playing') {
                        this.playTone(notes[note % 8], 'triangle', 0.15);
                        note++;
                    }
                }, 250); // 120 BPM-ish
            }
        };

        /**
         * GAME ENGINE
         */
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false }); // Optimize for no alpha on canvas background
        
        // Virtual Resolution (Logic runs here, renders scaled)
        const V_WIDTH = 1280;
        const V_HEIGHT = 720;
        let scale = 1;

        // Game Constants
        const GRAVITY = 2200;
        const JUMP_FORCE = -900;
        const MOVE_SPEED = 600;
        const GROUND_Y = 600;
        
        // State
        let gameState = 'menu'; // menu, playing, gameover
        let lastTime = 0;
        let distance = 0;
        let highScore = parseFloat(localStorage.getItem('geoDashHigh') || 0);
        let shake = 0;
        
        // Entities
        const player = {
            x: 200, y: 0, size: 50,
            vy: 0, rotation: 0,
            grounded: false,
            dead: false,
            color: '#00ffff'
        };

        let obstacles = [];
        let particles = []; // Object pool
        const PARTICLE_POOL_SIZE = 100;

        // Initialize Particle Pool
        for(let i=0; i<PARTICLE_POOL_SIZE; i++) {
            particles.push({ x:0, y:0, vx:0, vy:0, life:0, active: false, color: '#fff' });
        }

        // Input Handling
        let jumpPressed = false;
        
        function handleInput(e) {
            if (e.type !== 'keydown' && e.type !== 'touchstart' && e.type !== 'mousedown') return;
            if (e.type === 'keydown' && e.code !== 'Space' && e.code !== 'ArrowUp') return;
            e.preventDefault();
            
            if (gameState === 'playing') {
                if (player.grounded) {
                    player.vy = JUMP_FORCE;
                    player.grounded = false;
                    AudioSys.jump();
                    spawnParticles(player.x, player.y + player.size, 10, '#fff');
                }
            } else if (gameState === 'gameover') {
                resetGame();
            }
        }

        window.addEventListener('keydown', handleInput);
        window.addEventListener('touchstart', handleInput, { passive: false });
        window.addEventListener('mousedown', handleInput);

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            // Calculate scale to fit virtual resolution into screen
            scale = Math.min(canvas.width / V_WIDTH, canvas.height / V_HEIGHT);
            // Adjust scale to fill width (runner style)
            scale = canvas.height / V_HEIGHT; 
        }
        window.addEventListener('resize', resize);
        resize();

        function spawnParticles(x, y, count, color) {
            let spawned = 0;
            for(let p of particles) {
                if(!p.active) {
                    p.active = true;
                    p.x = x;
                    p.y = y;
                    p.vx = (Math.random() - 0.5) * 400;
                    p.vy = (Math.random() - 0.5) * 400;
                    p.life = 0.5 + Math.random() * 0.5;
                    p.color = color;
                    spawned++;
                    if(spawned >= count) break;
                }
            }
        }

        function resetGame() {
            player.y = GROUND_Y - player.size;
            player.vy = 0;
            player.rotation = 0;
            player.grounded = true;
            player.dead = false;
            
            distance = 0;
            obstacles = [];
            shake = 0;
            
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('startScreen').classList.add('hidden');
            gameState = 'playing';
            lastTime = performance.now();
            requestAnimationFrame(loop);
        }

        function gameOver() {
            gameState = 'gameover';
            player.dead = true;
            AudioSys.death();
            shake = 20;
            spawnParticles(player.x, player.y, 30, player.color);
            
            const score = (distance / 100).toFixed(0);
            if(score > highScore) {
                highScore = score;
                localStorage.setItem('geoDashHigh', highScore);
                document.getElementById('bestVal').textContent = highScore + "%";
            }
            
            document.getElementById('finalScore').textContent = score + "%";
            setTimeout(() => {
                document.getElementById('gameOverScreen').classList.remove('hidden');
            }, 500);
        }

        function spawnObstacle() {
            const type = Math.random() > 0.5 ? 'spike' : 'block';
            let obs = {
                x: V_WIDTH + 100,
                y: GROUND_Y,
                w: 50, h: 50,
                type: type,
                passed: false,
                color: type === 'spike' ? '#ff4757' : '#ffa502'
            };

            if (type === 'spike') {
                obs.h = 60;
                obs.w = 40;
                obs.y = GROUND_Y; 
            } else {
                // Block
                obs.y = GROUND_Y - 50;
            }
            obstacles.push(obs);
        }

        function update(dt) {
            if (player.dead) return;

            // Player Physics
            player.vy += GRAVITY * dt;
            player.y += player.vy * dt;

            // Ground Collision
            if (player.y > GROUND_Y - player.size) {
                player.y = GROUND_Y - player.size;
                player.vy = 0;
                player.grounded = true;
                
                // Snap rotation to nearest 90 deg
                const nearest90 = Math.round(player.rotation / (Math.PI/2)) * (Math.PI/2);
                player.rotation += (nearest90 - player.rotation) * 10 * dt;
            } else {
                player.grounded = false;
                player.rotation += 5 * dt; // Spin while jumping
            }

            // Obstacle Spawning logic
            distance += MOVE_SPEED * dt;
            
            // Simple Pattern: Spawn every ~1.5 seconds adjusted by speed randomness
            if (obstacles.length === 0 || (V_WIDTH + 100) - obstacles[obstacles.length-1].x > 400 + Math.random() * 300) {
                spawnObstacle();
            }

            // Update Obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                let obs = obstacles[i];
                obs.x -= MOVE_SPEED * dt;

                // Collision Detection (Hitbox slightly smaller than visual for fairness)
                const hitboxPadding = 10;
                const pRect = {
                    l: player.x + hitboxPadding,
                    r: player.x + player.size - hitboxPadding,
                    t: player.y + hitboxPadding,
                    b: player.y + player.size - hitboxPadding
                };
                
                let oRect = {
                    l: obs.x + 5,
                    r: obs.x + obs.w - 5,
                    t: obs.y - obs.h + 5,
                    b: obs.y
                };

                if (obs.type === 'block') {
                    oRect.t = obs.y;
                    oRect.b = obs.y + obs.h;
                }

                if (pRect.l < oRect.r && pRect.r > oRect.l &&
                    pRect.t < oRect.b && pRect.b > oRect.t) {
                    gameOver();
                }

                if (obs.x < -100) {
                    obstacles.splice(i, 1);
                }
            }

            // Update Particles
            for(let p of particles) {
                if(p.active) {
                    p.x += p.vx * dt;
                    p.y += p.vy * dt;
                    p.life -= dt;
                    if(p.life <= 0) p.active = false;
                }
            }

            // Screen Shake Decay
            if(shake > 0) {
                shake -= 100 * dt;
                if(shake < 0) shake = 0;
            }

            // UI
            document.getElementById('scoreVal').textContent = (distance / 100).toFixed(0) + "%";
        }

        function draw() {
            // Clear Background
            ctx.fillStyle = '#050505';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            
            // Apply Virtual Resolution Scale
            // Center the virtual screen vertically
            const offsetY = (canvas.height - V_HEIGHT * scale) / 2;
            ctx.translate(0, offsetY);
            ctx.scale(scale, scale);

            // Camera Shake
            if (shake > 0) {
                ctx.translate((Math.random()-0.5)*shake, (Math.random()-0.5)*shake);
            }

            // Draw Background Grid (Parallax)
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
            ctx.lineWidth = 2;
            const gridOffset = -(distance * 0.5) % 100;
            
            ctx.beginPath();
            // Floor lines
            for(let i=0; i<20; i++) {
                let x = gridOffset + i * 100;
                ctx.moveTo(x, GROUND_Y);
                ctx.lineTo(x - 200, V_HEIGHT);
            }
            // Horizon line
            ctx.moveTo(0, GROUND_Y);
            ctx.lineTo(V_WIDTH, GROUND_Y);
            ctx.stroke();

            // Draw Ground Fill
            const grad = ctx.createLinearGradient(0, GROUND_Y, 0, V_HEIGHT);
            grad.addColorStop(0, 'rgba(0, 255, 255, 0.2)');
            grad.addColorStop(1, 'transparent');
            ctx.fillStyle = grad;
            ctx.fillRect(0, GROUND_Y, V_WIDTH, V_HEIGHT - GROUND_Y);

            if (!player.dead) {
                // Draw Player (Layered Glow - Faster than shadowBlur)
                ctx.save();
                ctx.translate(player.x + player.size/2, player.y + player.size/2);
                ctx.rotate(player.rotation);
                
                // Outer Glow (Low Opacity)
                ctx.fillStyle = 'rgba(0, 255, 255, 0.2)';
                ctx.fillRect(-player.size/2 - 6, -player.size/2 - 6, player.size + 12, player.size + 12);
                
                // Inner Glow (Med Opacity)
                ctx.fillStyle = 'rgba(0, 255, 255, 0.5)';
                ctx.fillRect(-player.size/2 - 3, -player.size/2 - 3, player.size + 6, player.size + 6);
                
                // Solid Core
                ctx.fillStyle = player.color;
                ctx.fillRect(-player.size/2, -player.size/2, player.size, player.size);
                
                // Detail
                ctx.fillStyle = '#000';
                ctx.fillRect(-player.size/4, -player.size/4, player.size/2, player.size/2);
                
                ctx.restore();
            }

            // Draw Obstacles
            for (let obs of obstacles) {
                if (obs.type === 'spike') {
                    ctx.fillStyle = obs.color;
                    ctx.beginPath();
                    ctx.moveTo(obs.x, obs.y);
                    ctx.lineTo(obs.x + obs.w/2, obs.y - obs.h);
                    ctx.lineTo(obs.x + obs.w, obs.y);
                    ctx.fill();
                    
                    // Glow
                    ctx.strokeStyle = 'rgba(255, 71, 87, 0.4)';
                    ctx.lineWidth = 4;
                    ctx.stroke();
                } else {
                    // Block
                    ctx.fillStyle = obs.color;
                    ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
                    
                    // Border
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(obs.x, obs.y, obs.w, obs.h);
                }
            }

            // Draw Particles
            for (let p of particles) {
                if (p.active) {
                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = p.color;
                    ctx.fillRect(p.x, p.y, 6, 6);
                    ctx.globalAlpha = 1;
                }
            }

            ctx.restore();
        }

        function loop(timestamp) {
            // Calculate Delta Time (Limit to 0.1 to prevent huge jumps on lag)
            const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
            lastTime = timestamp;

            if (gameState !== 'menu') {
                update(dt);
            }
            draw();
            requestAnimationFrame(loop);
        }

        // Initialize UI
        document.getElementById('startBtn').addEventListener('click', () => {
            AudioSys.init(); // Initialize audio context on user interaction
            resetGame();
        });
        
        document.getElementById('restartBtn').addEventListener('click', resetGame);
        
        document.getElementById('bestVal').textContent = highScore + "%";

        // Start rendering menu loop
        requestAnimationFrame(loop);

    </script>
</body>
</html>
