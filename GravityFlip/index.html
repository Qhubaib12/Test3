<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gravity Flip: Phase Shift</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Exo+2:wght@400;700;900&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; user-select: none; }
        
        body {
            background: #050505;
            font-family: 'Exo 2', sans-serif;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            color: #fff;
        }
        
        #gameContainer {
            position: relative;
            width: 100%;
            height: 100%;
            background: #000;
        }

        canvas { display: block; width: 100%; height: 100%; }

        /* UI Layer */
        #uiLayer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
            padding: 20px;
        }

        .hud-top {
            display: flex; justify-content: space-between; align-items: flex-start;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .stat-box { text-align: center; }
        .label { font-size: 10px; color: #888; letter-spacing: 2px; margin-bottom: 4px; }
        .value { font-size: 24px; font-weight: 900; }
        .accent { color: #00ff88; text-shadow: 0 0 15px rgba(0, 255, 136, 0.6); }

        /* Screens */
        #startScreen, #gameOverScreen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 5, 10, 0.85);
            backdrop-filter: blur(8px);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 20; pointer-events: auto;
            transition: opacity 0.3s;
        }

        h1 {
            font-size: clamp(40px, 8vw, 80px); margin-bottom: 10px;
            background: linear-gradient(to right, #00ff88, #00d4ff);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 20px rgba(0, 255, 136, 0.3));
            font-style: italic;
        }

        p { font-size: 14px; color: #aaa; margin-bottom: 30px; letter-spacing: 1px; }

        button {
            background: transparent; color: #00ff88;
            border: 2px solid #00ff88;
            padding: 15px 50px;
            font-family: 'Exo 2', sans-serif;
            font-size: 18px; font-weight: 900;
            cursor: pointer; text-transform: uppercase;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.1);
            transition: all 0.2s;
            clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
        }

        button:hover {
            background: #00ff88; color: #000;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.6);
            transform: scale(1.05);
        }

        .hidden { opacity: 0; pointer-events: none; }

        /* Scanlines */
        .scanlines {
            position: absolute; inset: 0; pointer-events: none; z-index: 10;
            background: linear-gradient(transparent 50%, rgba(0, 0, 0, 0.3) 50%);
            background-size: 100% 4px;
            opacity: 0.5;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div class="scanlines"></div>
        
        <div id="uiLayer">
            <div class="hud-top">
                <div class="stat-box" style="text-align: left;">
                    <div style="font-weight: 900; font-style: italic; font-size: 20px;">GRAVITY<br>FLIP</div>
                </div>
                <div class="stat-box">
                    <div class="label">SCORE</div>
                    <div class="value accent" id="scoreVal">0000</div>
                </div>
                <div class="stat-box">
                    <div class="label">BEST</div>
                    <div class="value" id="bestVal">0000</div>
                </div>
            </div>
            <div style="text-align: center; margin-bottom: 20px;">
                <div class="label">CURRENT PHASE</div>
                <div id="phaseIndicator" style="width: 40px; height: 40px; border-radius: 50%; border: 3px solid #fff; margin: 5px auto; transition: background 0.2s;"></div>
            </div>
        </div>

        <div id="startScreen">
            <h1>GRAVITY FLIP</h1>
            <p>TAP TO FLIP GRAVITY â€¢ MATCH COLORS TO PHASE THROUGH</p>
            <button id="startBtn">ENGAGE</button>
        </div>

        <div id="gameOverScreen" class="hidden">
            <h1 style="color: #ff4757; -webkit-text-fill-color: #ff4757; filter: drop-shadow(0 0 20px rgba(255, 71, 87, 0.4));">CRITICAL FAILURE</h1>
            <p>FINAL SCORE: <span id="finalScore" style="color:#fff">0</span></p>
            <button id="restartBtn">REBOOT</button>
        </div>
    </div>

    <script>
        /**
         * AUDIO SYSTEM (Web Audio API)
         * No external files required.
         */
        const AudioSys = {
            ctx: null,
            init() {
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
            },
            playTone(freq, type, duration, vol = 0.1) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(freq/2, this.ctx.currentTime + duration);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },
            flip() { this.playTone(300, 'square', 0.15, 0.1); },
            phase() { this.playTone(600, 'sine', 0.3, 0.05); },
            crash() { 
                this.playTone(100, 'sawtooth', 0.5, 0.3);
                this.playTone(50, 'square', 0.5, 0.3);
            }
        };

        /**
         * GAME ENGINE
         */
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });

        // Virtual Resolution (Logic runs here, scales to screen)
        const V_WIDTH = 1920;
        const V_HEIGHT = 1080;
        let scale = 1;

        // Colors
        const COLORS = [
            { hex: '#00ff88', name: 'Green' }, // Neon Green
            { hex: '#00d4ff', name: 'Blue' },  // Cyan
            { hex: '#ff0055', name: 'Red' },   // Pink/Red
            { hex: '#ffcc00', name: 'Yellow' } // Gold
        ];

        // Game State
        let state = {
            running: false,
            score: 0,
            highScore: parseInt(localStorage.getItem('gf_best') || 0),
            speed: 900, // Pixels per second
            gravity: 3500,
            gDir: 1, // 1 = down, -1 = up
            lastTime: 0,
            shake: 0,
            colorTimer: 0
        };

        // Entities
        const player = {
            x: 300, y: V_HEIGHT/2,
            w: 60, h: 60,
            vy: 0,
            colorIdx: 0,
            trail: []
        };

        let obstacles = [];
        let particles = []; // Object pool

        // Particle Pool Setup
        const POOL_SIZE = 100;
        for(let i=0; i<POOL_SIZE; i++) particles.push({ active: false, x:0, y:0, vx:0, vy:0, life:0, color:'#fff' });

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            scale = Math.min(canvas.width / V_WIDTH, canvas.height / V_HEIGHT);
            // Force fill width for runner style
            scale = canvas.height / V_HEIGHT; 
        }
        window.addEventListener('resize', resize);
        resize();

        // Input
        function handleInput(e) {
            if (e.type !== 'keydown' && e.type !== 'touchstart' && e.type !== 'mousedown') return;
            if (e.type === 'keydown' && e.code !== 'Space' && e.code !== 'ArrowUp') return;
            e.preventDefault();

            if (state.running) {
                state.gDir *= -1;
                AudioSys.flip();
                spawnParticles(player.x + player.w/2, player.y + player.h/2, 15, COLORS[player.colorIdx].hex);
            } else if (document.getElementById('gameOverScreen').style.opacity !== '0') {
                // Debounce restart slightly
            }
        }
        window.addEventListener('keydown', handleInput);
        window.addEventListener('touchstart', handleInput, { passive: false });
        window.addEventListener('mousedown', handleInput);

        function spawnParticles(x, y, count, color) {
            let spawned = 0;
            for(let p of particles) {
                if(!p.active) {
                    p.active = true;
                    p.x = x; p.y = y;
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 300 + 100;
                    p.vx = Math.cos(angle) * speed;
                    p.vy = Math.sin(angle) * speed;
                    p.life = 0.5 + Math.random() * 0.5;
                    p.color = color;
                    spawned++;
                    if(spawned >= count) break;
                }
            }
        }

        function resetGame() {
            player.y = V_HEIGHT / 2;
            player.vy = 0;
            player.trail = [];
            player.colorIdx = 0;
            
            state.score = 0;
            state.speed = 900;
            state.gDir = 1;
            state.shake = 0;
            state.colorTimer = 0;
            obstacles = [];
            
            // Initial Obstacle
            spawnObstacle(V_WIDTH + 500);

            document.getElementById('scoreVal').innerText = '0000';
            document.getElementById('bestVal').innerText = state.highScore.toString().padStart(4, '0');
            document.getElementById('phaseIndicator').style.backgroundColor = COLORS[0].hex;
            
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('gameOverScreen').classList.add('hidden');
            
            state.running = true;
            state.lastTime = performance.now();
            requestAnimationFrame(loop);
        }

        function gameOver() {
            state.running = false;
            state.shake = 30;
            AudioSys.crash();
            spawnParticles(player.x, player.y, 50, COLORS[player.colorIdx].hex);
            
            if(state.score > state.highScore) {
                state.highScore = Math.floor(state.score);
                localStorage.setItem('gf_best', state.highScore);
            }

            document.getElementById('finalScore').innerText = Math.floor(state.score);
            setTimeout(() => {
                document.getElementById('gameOverScreen').classList.remove('hidden');
            }, 500);
        }

        function spawnObstacle(xOffset) {
            const type = Math.random();
            let obs = {
                x: xOffset,
                y: 0, w: 80, h: 0,
                colorIdx: Math.floor(Math.random() * COLORS.length),
                passed: false
            };

            // Difficulty scaling
            const gapSize = Math.max(250, 450 - (state.score * 0.05)); 

            if (type < 0.33) {
                // Top Pillar
                obs.y = 0;
                obs.h = Math.random() * (V_HEIGHT * 0.6) + 100;
            } else if (type < 0.66) {
                // Bottom Pillar
                obs.h = Math.random() * (V_HEIGHT * 0.6) + 100;
                obs.y = V_HEIGHT - obs.h;
            } else {
                // Floating Bar (Phase check)
                obs.h = 300;
                obs.y = (V_HEIGHT / 2) - 150;
                obs.w = 60;
            }
            
            obstacles.push(obs);
        }

        function update(dt) {
            // Speed Scaling
            state.speed = 900 + (state.score * 0.2);
            state.score += dt * 10;
            document.getElementById('scoreVal').innerText = Math.floor(state.score).toString().padStart(4, '0');

            // Player Physics
            player.vy += state.gravity * state.gDir * dt;
            player.y += player.vy * dt;

            // Floor/Ceiling Collision
            if (player.y < 0) {
                player.y = 0;
                player.vy = 0;
            } else if (player.y + player.h > V_HEIGHT) {
                player.y = V_HEIGHT - player.h;
                player.vy = 0;
            }

            // Color Cycling
            state.colorTimer += dt;
            if (state.colorTimer > 3.0) { // Change color every 3 seconds
                state.colorTimer = 0;
                player.colorIdx = (player.colorIdx + 1) % COLORS.length;
                document.getElementById('phaseIndicator').style.backgroundColor = COLORS[player.colorIdx].hex;
                // Flash effect on player
                spawnParticles(player.x + player.w/2, player.y + player.h/2, 5, '#fff');
            }

            // Trail Logic
            if (state.running) {
                player.trail.push({x: player.x, y: player.y});
                if (player.trail.length > 10) player.trail.shift();
            }

            // Obstacle Logic
            if (obstacles.length === 0 || (V_WIDTH + 200) - obstacles[obstacles.length-1].x > 600) {
                spawnObstacle(V_WIDTH + 100);
            }

            for (let i = obstacles.length - 1; i >= 0; i--) {
                let o = obstacles[i];
                o.x -= state.speed * dt;

                // AABB Collision
                if (player.x < o.x + o.w && player.x + player.w > o.x &&
                    player.y < o.y + o.h && player.y + player.h > o.y) {
                    
                    // Phase Mechanic: If colors match, you pass through
                    if (o.colorIdx === player.colorIdx) {
                        if (!o.passed) {
                            o.passed = true;
                            AudioSys.phase();
                            state.score += 50; // Bonus for phasing
                        }
                    } else {
                        gameOver();
                    }
                }

                if (o.x < -200) obstacles.splice(i, 1);
            }

            // Particles
            for (let p of particles) {
                if (p.active) {
                    p.x += p.vx * dt;
                    p.y += p.vy * dt;
                    p.life -= dt;
                    if (p.life <= 0) p.active = false;
                }
            }

            // Shake Decay
            if (state.shake > 0) state.shake = Math.max(0, state.shake - 100 * dt);
        }

        function draw() {
            // Clear
            ctx.fillStyle = '#050505';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            
            // Virtual Resolution scaling
            // Center the view vertically if screen aspect ratio is taller than 16:9
            const yOffset = (canvas.height - V_HEIGHT * scale) / 2;
            ctx.translate(0, yOffset);
            ctx.scale(scale, scale);

            // Camera Shake
            if (state.shake > 0) {
                ctx.translate((Math.random()-0.5)*state.shake, (Math.random()-0.5)*state.shake);
            }

            // Background Grid (Parallax)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 2;
            const gridX = -(state.score * 5) % 100;
            
            ctx.beginPath();
            for (let i=0; i<25; i++) {
                let x = gridX + i * 100;
                ctx.moveTo(x, 0); ctx.lineTo(x - 300, V_HEIGHT);
            }
            // Horizon lines
            ctx.moveTo(0, 0); ctx.lineTo(V_WIDTH, 0);
            ctx.moveTo(0, V_HEIGHT); ctx.lineTo(V_WIDTH, V_HEIGHT);
            ctx.stroke();

            // Draw Trail
            ctx.fillStyle = COLORS[player.colorIdx].hex;
            ctx.globalAlpha = 0.3;
            for(let t of player.trail) {
                ctx.fillRect(t.x, t.y, player.w, player.h);
            }
            ctx.globalAlpha = 1.0;

            // Draw Player (Glow via Additive Blending - Fast)
            if (state.running || state.shake > 0) {
                ctx.globalCompositeOperation = 'lighter';
                ctx.fillStyle = COLORS[player.colorIdx].hex;
                // Core
                ctx.fillRect(player.x, player.y, player.w, player.h);
                // Glow
                ctx.globalAlpha = 0.3;
                ctx.fillRect(player.x - 5, player.y - 5, player.w + 10, player.h + 10);
                ctx.fillRect(player.x - 10, player.y - 10, player.w + 20, player.h + 20);
                
                // Gravity Indicator Arrow
                ctx.globalAlpha = 1.0;
                ctx.globalCompositeOperation = 'source-over';
                ctx.fillStyle = '#000';
                ctx.beginPath();
                const cx = player.x + player.w/2;
                const cy = player.y + player.h/2;
                const dir = state.gDir; // 1 down, -1 up
                ctx.moveTo(cx, cy + (10 * dir));
                ctx.lineTo(cx - 10, cy - (5 * dir));
                ctx.lineTo(cx + 10, cy - (5 * dir));
                ctx.fill();
            }

            // Draw Obstacles
            for (let o of obstacles) {
                const color = COLORS[o.colorIdx].hex;
                
                // Phased out look if matching color
                if (o.colorIdx === player.colorIdx) {
                    ctx.globalAlpha = 0.2;
                    ctx.fillStyle = color;
                    ctx.fillRect(o.x, o.y, o.w, o.h);
                    ctx.globalAlpha = 1.0;
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(o.x, o.y, o.w, o.h);
                } else {
                    // Solid Danger
                    ctx.fillStyle = color;
                    ctx.fillRect(o.x, o.y, o.w, o.h);
                    // Neon Edge
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.fillStyle = 'rgba(255,255,255,0.3)';
                    ctx.fillRect(o.x, o.y, 5, o.h); // Left edge highlight
                    ctx.globalCompositeOperation = 'source-over';
                }
            }

            // Draw Particles
            for (let p of particles) {
                if (p.active) {
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = p.life;
                    ctx.fillRect(p.x, p.y, 4, 4);
                }
            }
            ctx.globalAlpha = 1.0;

            ctx.restore();
        }

        function loop(timestamp) {
            // Calculate Delta Time (Cap at 0.1 to prevent explosions on lag)
            const dt = Math.min((timestamp - state.lastTime) / 1000, 0.1);
            state.lastTime = timestamp;

            if (state.running) update(dt);
            draw();
            requestAnimationFrame(loop);
        }

        // Init Listeners
        document.getElementById('startBtn').addEventListener('click', () => {
            AudioSys.init();
            resetGame();
        });
        document.getElementById('restartBtn').addEventListener('click', resetGame);

        // Initial render
        resize();
        requestAnimationFrame(loop);

    </script>
</body>
</html>
