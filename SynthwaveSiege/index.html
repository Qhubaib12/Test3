<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Chain Reaction: Overcharge</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        :root {
            --bg-dark: #050505;
            --accent: #00ff88;
            --grid-gap: 8px;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }
        
        body {
            background: var(--bg-dark);
            font-family: 'Orbitron', monospace;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            touch-action: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: #fff;
        }

        /* Background Grid Effect */
        .bg-scanlines {
            position: absolute; inset: 0; pointer-events: none; z-index: 0;
            background: linear-gradient(transparent 50%, rgba(0, 255, 136, 0.02) 50%);
            background-size: 100% 4px;
        }

        /* UI Layer */
        #ui-layer {
            width: 100%;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(180deg, rgba(0,0,0,0.9) 0%, transparent 100%);
            z-index: 10;
            height: 80px;
        }

        .stat-box { text-align: center; }
        .stat-label { font-size: 10px; color: #888; letter-spacing: 1px; }
        .stat-val { font-size: 24px; font-weight: 900; text-shadow: 0 0 10px rgba(255,255,255,0.3); }
        .moves-warn { color: #ff4757; animation: pulse 0.5s infinite alternate; }

        /* Game Area */
        #game-stage {
            position: relative;
            flex: 1;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 5;
        }

        #grid {
            display: grid;
            gap: var(--grid-gap);
            position: relative;
            z-index: 5;
            padding: 10px;
            transition: transform 0.1s;
        }

        .shake { animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both; }

        /* Canvas Overlay for Particles */
        #fx-canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 20;
        }

        /* Cell Styling */
        .cell {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            position: relative;
            cursor: pointer;
            transition: transform 0.1s, border-color 0.2s;
            border: 2px solid transparent;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .cell-inner {
            width: 100%; height: 100%;
            border-radius: 10px;
            transition: all 0.3s ease-out;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: inset 0 0 15px rgba(0,0,0,0.5);
        }

        /* Charges (Dots) */
        .charge-indicator {
            width: 12px; height: 12px;
            background: #fff;
            border-radius: 50%;
            box-shadow: 0 0 10px #fff;
            position: absolute;
            transition: 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            transform: scale(0);
        }

        /* Charge Positions */
        .c1 .dot-1 { transform: scale(1); }
        .c2 .dot-1 { transform: translate(-8px, 0) scale(1); }
        .c2 .dot-2 { transform: translate(8px, 0) scale(1); }
        .c3 .dot-1 { transform: translate(0, -8px) scale(1); }
        .c3 .dot-2 { transform: translate(8px, 6px) scale(1); }
        .c3 .dot-3 { transform: translate(-8px, 6px) scale(1); }

        /* Wildcard Styling */
        .cell.wildcard .cell-inner {
            background: conic-gradient(from 0deg, #ff0000, #00ff00, #0000ff, #ff0000);
            animation: spin 2s linear infinite;
        }
        .cell.wildcard::after {
            content: '★'; font-size: 20px; position: absolute; z-index: 2; color: white;
        }

        /* Modals */
        .modal {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            z-index: 50;
            opacity: 0; pointer-events: none;
            transition: opacity 0.3s;
            backdrop-filter: blur(5px);
        }
        .modal.active { opacity: 1; pointer-events: all; }

        .btn {
            background: var(--accent); border: none; padding: 15px 40px;
            font-family: 'Orbitron'; font-weight: 900; font-size: 18px;
            clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
            cursor: pointer; margin-top: 20px;
            transition: transform 0.1s, filter 0.1s;
        }
        .btn:active { transform: scale(0.95); filter: brightness(0.8); }

        /* Tutorial Box */
        #tutorial-box {
            position: absolute; bottom: 20px;
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid var(--accent);
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 12px; text-align: center;
            pointer-events: none;
            z-index: 8;
        }

        @keyframes spin { 100% { transform: rotate(360deg); } }
        @keyframes pulse { 0% { transform: scale(1); } 100% { transform: scale(1.1); } }
        @keyframes shake { 10%, 90% { transform: translate3d(-1px, 0, 0); } 20%, 80% { transform: translate3d(2px, 0, 0); } 30%, 50%, 70% { transform: translate3d(-4px, 0, 0); } 40%, 60% { transform: translate3d(4px, 0, 0); } }
    </style>
</head>
<body>

    <canvas id="fx-canvas"></canvas>
    <div class="bg-scanlines"></div>

    <div id="ui-layer">
        <div class="stat-box">
            <div class="stat-label">SCORE</div>
            <div class="stat-val" id="score-el">0</div>
        </div>
        <div class="stat-box">
            <div class="stat-label">MOVES</div>
            <div class="stat-val" id="moves-el">20</div>
        </div>
    </div>

    <div id="game-stage">
        <div id="grid"></div>
    </div>

    <div id="tutorial-box">
        TAP to Charge • Max Charge = EXPLODE<br>
        Explosions charge neighbors • Same Colors Chain Instantly
    </div>

    <!-- Game Over Modal -->
    <div id="modal-gameover" class="modal">
        <h1 style="font-size: 40px; color: #ff4757; margin-bottom: 10px;">OUT OF MOVES</h1>
        <div style="font-size: 14px; color: #888;">FINAL SCORE</div>
        <div id="final-score" style="font-size: 50px; color: #fff; margin-bottom: 20px;">0</div>
        <button class="btn" onclick="Game.restart()">RETRY SYSTEM</button>
    </div>

    <script>
        // --- Audio Engine (Web Audio API) ---
        const AudioSys = {
            ctx: null,
            init() {
                if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            },
            playTone(freq, type, dur, vol = 0.1) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(freq * 0.5, this.ctx.currentTime + dur);
                
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + dur);
                
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + dur);
            },
            playPop() { this.playTone(600 + Math.random()*200, 'sine', 0.1, 0.1); },
            playExplode() { this.playTone(100 + Math.random()*50, 'square', 0.3, 0.2); },
            playChain() { this.playTone(800 + Math.random()*400, 'triangle', 0.15, 0.1); }
        };

        // --- Particle System (Canvas) ---
        const FX = {
            canvas: document.getElementById('fx-canvas'),
            ctx: document.getElementById('fx-canvas').getContext('2d'),
            particles: [],
            texts: [],
            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            },
            spawnExplosion(x, y, color) {
                for(let i=0; i<12; i++) {
                    const angle = (Math.PI * 2 / 12) * i;
                    const speed = 2 + Math.random() * 4;
                    this.particles.push({
                        x, y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 1.0,
                        color: color,
                        size: 4 + Math.random() * 4
                    });
                }
            },
            spawnText(x, y, text, color) {
                this.texts.push({ x, y, text, color, life: 1.0, dy: 0 });
            },
            loop() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Particles
                for(let i=this.particles.length-1; i>=0; i--) {
                    const p = this.particles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life -= 0.02;
                    p.size *= 0.95;
                    
                    this.ctx.globalAlpha = p.life;
                    this.ctx.fillStyle = p.color;
                    this.ctx.beginPath();
                    this.ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
                    this.ctx.fill();
                    
                    if(p.life <= 0) this.particles.splice(i, 1);
                }

                // Floating Text
                this.ctx.font = "bold 24px Orbitron";
                this.ctx.textAlign = "center";
                for(let i=this.texts.length-1; i>=0; i--) {
                    const t = this.texts[i];
                    t.dy -= 1;
                    t.life -= 0.015;
                    
                    this.ctx.globalAlpha = t.life;
                    this.ctx.fillStyle = t.color;
                    this.ctx.shadowBlur = 10;
                    this.ctx.shadowColor = t.color;
                    this.ctx.fillText(t.text, t.x, t.y + t.dy);
                    this.ctx.shadowBlur = 0;

                    if(t.life <= 0) this.texts.splice(i, 1);
                }
                this.ctx.globalAlpha = 1;
                requestAnimationFrame(() => this.loop());
            }
        };

        // --- Game Logic ---
        const Game = {
            cols: 6,
            rows: 6,
            colors: ['#ff4757', '#2ed573', '#3742fa', '#ffa502', '#a29bfe'],
            grid: [],
            moves: 20,
            score: 0,
            isProcessing: false,
            combo: 0,

            init() {
                AudioSys.init();
                FX.resize();
                FX.loop();
                window.addEventListener('resize', () => FX.resize());
                
                // Setup Grid Layout
                const gridEl = document.getElementById('grid');
                const size = Math.min(window.innerWidth - 40, 500);
                const cellSize = (size - (this.cols-1)*8) / this.cols;
                
                gridEl.style.gridTemplateColumns = `repeat(${this.cols}, ${cellSize}px)`;
                gridEl.style.width = `${size}px`;
                gridEl.style.height = `${size}px`;

                // Generate Cells
                gridEl.innerHTML = '';
                this.grid = [];
                for(let i=0; i<this.cols * this.rows; i++) {
                    const el = document.createElement('div');
                    el.className = 'cell c0';
                    el.innerHTML = `
                        <div class="cell-inner">
                            <div class="charge-indicator dot-1"></div>
                            <div class="charge-indicator dot-2"></div>
                            <div class="charge-indicator dot-3"></div>
                        </div>
                    `;
                    el.onclick = () => this.clickCell(i);
                    gridEl.appendChild(el);
                    
                    this.grid.push({
                        idx: i,
                        el: el,
                        inner: el.querySelector('.cell-inner'),
                        colorIdx: -1,
                        charge: 0,
                        type: 'normal' // or 'wildcard'
                    });
                }
                this.restart();
            },

            restart() {
                this.score = 0;
                this.moves = 25;
                this.combo = 0;
                this.isProcessing = false;
                document.getElementById('modal-gameover').classList.remove('active');
                
                this.grid.forEach(cell => {
                    this.resetCell(cell);
                    this.setCellColor(cell, Math.floor(Math.random() * this.colors.length));
                });
                this.updateUI();
            },

            resetCell(cell) {
                cell.charge = 0;
                cell.type = Math.random() < 0.02 ? 'wildcard' : 'normal'; // 2% chance for wildcard
                this.updateCellVisuals(cell);
            },

            setCellColor(cell, colorIdx) {
                cell.colorIdx = colorIdx;
                const color = this.colors[colorIdx];
                cell.inner.style.backgroundColor = color;
                cell.inner.style.boxShadow = `0 0 15px ${color}80`; // Hex opacity
                if(cell.type === 'wildcard') {
                    cell.el.classList.add('wildcard');
                    cell.inner.style.backgroundColor = 'transparent';
                } else {
                    cell.el.classList.remove('wildcard');
                }
            },

            updateCellVisuals(cell) {
                cell.el.className = `cell c${cell.charge} ${cell.type === 'wildcard' ? 'wildcard' : ''}`;
            },

            clickCell(idx) {
                if(this.isProcessing || this.moves <= 0) return;
                
                AudioSys.init(); // Ensure context started
                this.moves--;
                this.updateUI();
                
                this.addCharge(this.grid[idx], true);
            },

            addCharge(cell, isUserClick) {
                if(cell.charge < 3) {
                    cell.charge++;
                    this.updateCellVisuals(cell);
                    AudioSys.playPop();
                } else {
                    // Explode!
                    this.processExplosion(cell, isUserClick);
                }
            },

            async processExplosion(startCell, isTrigger) {
                this.isProcessing = true;
                const queue = [startCell];
                const explodedIndices = new Set();
                let chainCount = 0;

                while(queue.length > 0) {
                    const cell = queue.shift();
                    if(explodedIndices.has(cell.idx)) continue;
                    explodedIndices.add(cell.idx);

                    // Visual FX
                    const rect = cell.el.getBoundingClientRect();
                    const color = cell.type === 'wildcard' ? '#ffffff' : this.colors[cell.colorIdx];
                    FX.spawnExplosion(rect.left + rect.width/2, rect.top + rect.height/2, color);
                    AudioSys.playExplode();
                    
                    if(chainCount > 0) {
                        this.score += (chainCount * 50);
                        FX.spawnText(rect.left + rect.width/2, rect.top, `+${chainCount*50}`, '#fff');
                    }

                    // Logic: Get neighbors
                    const neighbors = this.getNeighbors(cell.idx);
                    
                    // 1. Damage neighbors
                    // 2. If neighbor matches color (or wild), add to queue immediately (chain)
                    // 3. If neighbor diff color, add charge (tactical)
                    
                    for(let nIdx of neighbors) {
                        const nCell = this.grid[nIdx];
                        if(explodedIndices.has(nIdx)) continue;

                        const match = cell.type === 'wildcard' || nCell.type === 'wildcard' || cell.colorIdx === nCell.colorIdx;

                        if(match) {
                            // Instant Chain
                            AudioSys.playChain();
                            queue.push(nCell);
                        } else {
                            // Shockwave Charge
                            if(nCell.charge < 3) {
                                nCell.charge++;
                                this.updateCellVisuals(nCell);
                            } else {
                                // Overload!
                                queue.push(nCell); 
                            }
                        }
                    }

                    // Clear the exploded cell
                    this.resetCell(cell);
                    
                    // Small delay for chain visualization
                    chainCount++;
                    if(chainCount % 3 === 0) {
                        document.getElementById('grid').classList.add('shake');
                        setTimeout(()=>document.getElementById('grid').classList.remove('shake'), 200);
                    }
                    await new Promise(r => setTimeout(r, 80)); 
                }

                // Refill Grid
                this.refillGrid(explodedIndices);
            },

            async refillGrid(explodedSet) {
                // Drop logic
                for(let col=0; col<this.cols; col++) {
                    let writePos = this.rows - 1;
                    // Iterate bottom up
                    for(let row=this.rows-1; row>=0; row--) {
                        const idx = row * this.cols + col;
                        const cell = this.grid[idx];
                        
                        if(!explodedSet.has(idx)) {
                            // This cell is valid, move it to writePos
                            if(row !== writePos) {
                                const targetIdx = writePos * this.cols + col;
                                this.copyCellData(this.grid[idx], this.grid[targetIdx]);
                                explodedSet.add(idx); // Mark old position as empty effectively
                            }
                            writePos--;
                        }
                    }
                    
                    // Fill top with new
                    while(writePos >= 0) {
                        const idx = writePos * this.cols + col;
                        this.resetCell(this.grid[idx]);
                        this.setCellColor(this.grid[idx], Math.floor(Math.random() * this.colors.length));
                        writePos--;
                    }
                }

                // Bonus Moves for big chains
                if(explodedSet.size > 6) {
                    this.moves += 2;
                    FX.spawnText(window.innerWidth/2, window.innerHeight/2, "BONUS MOVES!", "#00ff88");
                }

                this.updateUI();
                this.isProcessing = false;
                
                if(this.moves <= 0) {
                    setTimeout(() => this.gameOver(), 500);
                }
            },

            copyCellData(src, dest) {
                dest.colorIdx = src.colorIdx;
                dest.charge = src.charge;
                dest.type = src.type;
                this.updateCellVisuals(dest);
                this.setCellColor(dest, dest.colorIdx);
            },

            getNeighbors(idx) {
                const n = [];
                const c = idx % this.cols;
                const r = Math.floor(idx / this.cols);
                if(c > 0) n.push(idx - 1);
                if(c < this.cols - 1) n.push(idx + 1);
                if(r > 0) n.push(idx - this.cols);
                if(r < this.rows - 1) n.push(idx + this.cols);
                return n;
            },

            updateUI() {
                document.getElementById('score-el').innerText = this.score;
                const movesEl = document.getElementById('moves-el');
                movesEl.innerText = this.moves;
                if(this.moves <= 5) movesEl.classList.add('moves-warn');
                else movesEl.classList.remove('moves-warn');
            },

            gameOver() {
                document.getElementById('final-score').innerText = this.score;
                document.getElementById('modal-gameover').classList.add('active');
            }
        };

        Game.init();

    </script>
</body>
</html>
